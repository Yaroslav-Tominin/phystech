
\documentclass[a4paper,12pt]{article} 




\usepackage[utf8]{inputenc}			 
\usepackage[english,russian]{babel}	
\usepackage[all]{xy}

%автомат
\usepackage{tikz}
\usetikzlibrary{arrows,automata}


% Математика
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 


\usepackage{wasysym}


\usepackage{graphicx}
\graphicspath{{pictures_tryap1/}}



\author{Томинин Ярослав, 778 группа}
\title{Домашнее задание №8}
\date{\today}


\begin{document} 

\maketitle
\newpage
\textbf{1.}\\



\begin{center} 
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm] 

\node[initial,state] (q_0)  {$q_0$}; 
\node[state,accepting] (q_1) [right of = q_0] {$q_0$}; 



\path[->]  (q_0) edge [in=-30,out=-150,loop] node 
{$a,Z_0/aZ_0; b,Z_0/bZ_0;a,a/aa;a,b/\epsilon;b,a/\epsilon;b,b/bb;$}(q_0);

\path[->]  (q_0) edge [bend left] node {$\epsilon, Z_0/\epsilon$} (q_1);





\end{tikzpicture} 
\end{center}

Докажем, почему этот автомат порождает требуемый язык. Назовем язык автомата L(A)\\
Докажем по индукции по длине слова, что слово $w \in L(A)$ тогда и только тогда, когда количество букв а и б одинаково.\\
\textbf{База:} n=0. Существует только одно слово $\epsilon$.Правда.\\
\textbf{Переход:} для длины n доказали, тогда рассмотрим слово длины n+1, допустим, что оно содержит одинаковое количество букв а и б, но не принимается автоматом. Тогда поймем, что в этом слове есть переход от а к б или ба. Обозначим его за $\alpha$. Тогда $w=w_1\alpha w_2$. Моймем, что по нашему предположению слово $w_1w_2$ принимается автоматом, так же заметим, что одно из правил, в которых в стек кладется $\epsilon$ будет использовано хотя бы 1 раз.(иначе у нас не было бы $\alpha$) Поэтому мы можем рассмотреть слово, в котором нет символов, которые были убраны из стека правилами, кладущими в стек только $\epsilon$. Но так как мы убрали символы аб или ба, то разность киличества букв а и б по прежнему равна 0, по предположению индукции это слово принимается. Это значит, что и то слово тоже принимается. Теперь докажем, что все слова, принимаемые автоматом, длины n+1 имеют одинаковое количество букв а и б. Наше слово может оказаться в допустимом состоянии только пе эпсилон переходу, так как из нашего стека убираются символы аб и ба, а добавляются все прочитанные, то если в конце у нас нет символов, то количество букв а и б одинаковое.\\
Следовательно, этот автомат порождает нужный язык.\\
\textbf{2.}
Алгоритм подсмотрен из книги.\\
\textbf{Алгоритм построения магазинного автомата по КС-грамматике.}: рассмотрим правило вывода $A \to \alpha$. Тогда наш автомат будет состоять из двух состояний $q_0,q_f$.
Причем для каждого вывода такого вида мы определим функцию перехода [{(важно, что делаем отдельный переход по $\epsilon$ для Z $\delta (q_0,\epsilon,Z)=(q_0,S)$)}]  $\delta (q_0,\epsilon,Z)={(q_0,\alpha)}$.(В частности для нашей задачи 
$\delta(q_0,\epsilon,S)={(q_0,SS),(q_0,(S)),(q_0,[S]),\epsilon}$).
 И еще переходы, связанные с обработкой символов: определим переход из начального состояния в начальное, где будем переходить по терминальному символу к следующим образом: $\delta (q_0,k,k)=(q_0,\epsilon)$. Осталось добавить переход в допускающее состояние: $\delta (\epsilon,Z)=(q_f,\epsilon)$\\
 Построим автомат по этому алгоритму









\begin{center} 
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm] 

\node[initial,state] (q_0)  {$q_0$}; 
\node[state,accepting] (q_1) [right of = q_0] {$q_0$}; 



\path[->]  (q_0) edge [in=-30,out=-150,loop] node 
{$\epsilon, S/SS;\epsilon, S/(S);\epsilon, S/[S];\epsilon, S/\epsilon;(, (/ \epsilon;), )/ \epsilon;[, [/ \epsilon;], ]/ \epsilon;$}(q_0);

\path[->]  (q_0) edge [bend left] node {$\epsilon, Z_0/\epsilon$} (q_1);





\end{tikzpicture} 
\end{center}


2)\\

\begin{center} 
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm] 

\node[initial,state] (q_0)  {$q_0$}; 
\node[state,accepting] (q_1) [right of = q_0] {$q_1$}; 



\path[->]  (q_0) edge [in=-30,out=-150,loop] node 
{$(, (/((;(, [/([;(, Z/(Z;  [, (/[(;[, [/[[;[, Z/(Z;   ),(/ \epsilon;     ],[/ \epsilon; $}(q_0);

\path[->]  (q_0) edge [bend left] node {$\epsilon, Z_0/\epsilon$} (q_1);





\end{tikzpicture} 
\end{center}


Докажем следующее утверждение по индукции по длине слова:\\
\textbf{Слово допустимо автоматом тогда и только тогда, когда оно выводимо из грамматики.}\\
\textbf{База:} Рассмотрим n=0. Из грамматики и из автомата выводимо слово $\epsilon$.\\
\textbf{Переход:} предположим, что для слов длины не больше, чем n выполнено.Предположим, что существует слово, которое  является правильной скобочной последовательностью, но при этом не выводимо автоматом. Так как это правильная скобочная последовательность, то существует подслово $\alpha= () or []$. Заметим, что когда мы доберемся до альфы, то стек не изменит состояния после прочтения альфы(прямо следует из построения). Именно поэтому мы можем рассмотреть слово исключив альфу. Поймем, что это будет правильная скобочная последовательность и по предположению ее должен принимать автомат. Поэтому и наше слово должно приниматьс. Противоречие. \\

Докажем, что все слова, которые выводимы автоматом-правильные скобочные последовательности. Предположим, что слово из неправильной скобочной последовательности выводимо автоматом. Рассмотрим момент, когда мы используем правило удаление скобок из стека(мы его точно используем, так как в конечном итоге в стеке не должно быть скобок). Тогда мы знаем, что эти скобки стояли рядом, так как это правило было применено впервые. Если мы уберем эти скобки из слова, то состояние автомата не изменится(так как состояние автомата не менялось при прочтении этиъ скобок). Но по нашему предположению слово не должно допускаться автоматом, так как оно не правильная скобочная последовательность. Противоречие.\\
\textbf{3.}\\


\begin{center} 
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm] 

\node[initial,state] (q_0)  {$q_0$}; 
\node[state] (q_1) [right of = q_0] {$q_1$}; 
\node[state] (q_2) [below right  of = q_0] {$q_2$}; 
\node[state,accepting] (q_3) [right  of = q_2] {$q_3$}; 



\path[->]  (q_0) edge [in=-45,out=-135,loop] node 
{$a,a/aa;    a,b/ab;     a,Z/aZ;    b,a/ba;    b,b/bb;     b,Z/bZ;    $}(q_0);

\path[->]  (q_0) edge [in=90,out=90] node {$a,a/a;    a,b/b;     a,Z/Z;    b,a/a;    b,b/b;     b,Z/Z;   \epsilon,a/a;    \epsilon,b/b;     \epsilon,Z/Z;  $} (q_1);

\path[->]  (q_1) edge [in=0,out=0] node {$a,b/\epsilon;   b,a/\epsilon;   $} (q_2);

\path[->]  (q_2) edge [in=-135,out=-45,loop] node {$a,b/\epsilon;   b,a/\epsilon;   a,a/\epsilon;   b,b/\epsilon;   $} (q_2);

\path[->]  (q_2) edge [bend right] node {$\epsilon,Z/\epsilon$} (q_3);



\path[->]  (q_1) edge [in=0,out=-90,loop] node {$ a,a/\epsilon;   b,b/\epsilon;   $} (q_1);

\end{tikzpicture} 
\end{center}
\textbf{Доказательсво корректности:}\\
\textbf{Лемма:} Если наш автомат принимает слово, то при переходе из 0 в 1 он прочитывает ровно половину слова, если это слово четное и половину с округлением вниз, если это слово нечетное. \\
\textbf{Доказательство леммы:} Поймем, что в состояниях 1,2 мы вычеркиваем символы из стека при прочтении символов, поэтому, чтобы мы смогли перейти в допускающее состояние мы должны вы порвых вычеркнуть все символы из стека(так как мы вычеркиваем по одному, то количество принятых в состояниях 1, 2  должно быть равно принятых в состоянии 0) и на этот момент(когда мы вычеркнем все символы из стека) все слово должно быть прочитанно(иначе получится, что мы умрем в допускающем состоянии). Поэтому лемма доказана.\\
\textbf{Докажем, что паллиндромы не принимаются нашим автоматом:} рассмотрим паллиндорм, по лемме мы перейдем в 1 состояние, когда прочитаем половину. Так как это палиндром, то мы не можем перейти из 1 состояния во второе(так как мы будем читать буквы, которые будут находиться сверху стека, поэтому, когда мы прочитаем все слово, мы будем находиться в 1 состоянии). Следовательно, паллиндром не принимается автоматом.\\
\textbf{Докажем, что не паллиндромы принимаются автоматом:} Рассмотрим не паллиндром. Тогда, когда мы перейдем в 1 состояние, то мы прочитаем половину слова(понятно, что для нечетного случаая мы прочитаем чуть больше половины, но последний прочитанный символ не заносится в стек, поэтому конфигурация автомата при прочтении центральной буквы остается неизменной и мы можем выкинуть центральный символ и ссвести этот случай к четной длине). Поймем, что у еас всегда будет возможность перейти из 1 состояния во 2(так как иначе мы уже доказали, что это будет паллиндром), поэтому, перейдя во 2 состояние, мы просто будем вычеркивать буквы из стека, пока не дождемся Z, по которому перейдем в допускающее состояние(на этот момент мы прочитаем все слово, это следует из леммы, так как мы рассмтравиваем только те случаи, когда мы читаем половину и переходим в 1 состояние, в других автомат умрет). \\
Мы доказали, что этот автомат принимает требуемый язык.\\
\textbf{4.}\\
\textbf{1)}\\
Рассмотрим языки \\$L_1={a^ib^i,i \geq 0}$;\\ $L_2={c^j,j \geq 0}$;\\$L_3={a^ic^i,i \geq 0}$;\\$L_4={b,j \geq 0}$.\\
Тогда язык $L_5=\lbrace a^ib^ic^k,i,j\geq 0\rbrace$ равен $L_5=L_1\cdot L_2$\\
\textbf{Запишем грамматику для $L_1$}\\
\textbf{$G_1$:}\\
\begin{align*}
	S_1&\to aS_1b|\epsilon\\\
\end{align*}
\textbf{Запишем грамматику для $L_2$}\\
\textbf{$G_2$:}\\
\begin{align*}
	S_2&\to cS_2|\epsilon\\\
\end{align*}
Не будем доказывать, что эти грамматики порождают нужные языки, так как это уже было проделанно нами не один раз.\\
Тогда в запишем грамматику объединения языков\\
\textbf{Грамматика для $L_5$}\\
\textbf{$G_5$:}\\
\begin{align*}
	S_5&\to S_1S_2\\\
	S_1&\to aS_1b|\epsilon\\\
	S_2&\to cS_2|\epsilon\\\
\end{align*}
Этот алгоритм проходился в классе, поэтому не будем доказывать его корректность.\\
Построим язык $L_6$\\
\textbf{Грамматика для $L_6$}\\
\textbf{$G_6$:}\\
\begin{align*}
	S_6&\to aS_6c|N\\\
	N&\to bN|\epsilon\\\
\end{align*}
Пока слово $\alpha$ содержит S, то оно стоит по середине слова, так как мы можем применять только 1 правило(здесь пользуемся тем, что у нас будет только один терминал)\\
Как только мы заменим S, то количество букв а и с будеи одинаковым. После замены мы можем добавить произвольное количество букв б. В конце концов мы можем получить произвольное слово из языка $L_6$ и только эти слова.\\
Теперь поймем, что $L=L_5 \cup L_6$\\
\textbf{Грамматика для $L$}\\
\textbf{$G$:}\\
\begin{align*}
	S&\to S_5|S_6\\\
	S_5&\to S_1S_2\\\
	S_1&\to aS_1b|\epsilon\\\
	S_2&\to cS_2|\epsilon\\\
	S_6&\to aS_6c|N\\\
	N&\to bN|\epsilon\\\
\end{align*}
\textbf{2)}\\
\begin{align*}
	S&\to AB|BA|A|B|\epsilon\\\
	A&\to aAa|aAb|bAa|bAb|a\\\
	B&\to bBb|bBa|aBa|aBb|b\\\
\end{align*}
\textbf{Любое слово, порождаемое грамматикой не является дополнением  тандемных слов:}\\
Предположим, что наша грамматика допускает тандемное слово.Поймем, что слова четной длины порождаются только через правило AB,BA. Следовательно, рассмотрим слово, которое порождается в 1 случае(для второго все аналогично). \\
$w=\underbrace{\alpha}_{K}a\underbrace{\beta}_{K}\cdot  \underbrace{\mu}_{M}b\underbrace{\delta}_{M}$\\
Заметим, что длина слова 2К+2М+2, но  на К+1 и 2К+М+2 местах стоят разные буквы. Поэтому мы пришли к противоречию и это было не тандемное слово.\\
\textbf{Наша грамматика порождает любое слово из дополнения языка тандемных слов:}\\
Рассмотрим слово, если оно нечетной длины, то мы умеем выводить их с помощью нетерминала А(или Б, тут без разницы). Рассмотрим слово четной длины 2n. Так как слово не является тандемом, то существует i<n: w[i]!=w[n+i](иначе бы слово было тандемом). Тогда породим часть w[1,2i-1] c помощью А, а часть w[2i,2n] c помощью B(если w[i]=a, иначе первую часть порождаем B, а вторую А). Так как они нечетной длины, то мы можем их породить. Следовательно, любой не тандем порожден нашей грамматикой.\\
\textbf{5.}\\
Применим операцию произведения, которую мы делали для регулярных языков со следующими правилами:\\
1)по прежнему состояние автомата соответствует двум состояниям, по одному от каждого автомата.\\
2)за стек будет отвечать только магазинный автомат: то есть переходя из состояния в стек будет ложиться то, что положил бы магазинный автомат, по переходу из состояния, которое соответствует этому состоянию, в состояние, которое соответствует состоянию , в которое мы переходим.\\
3)допускающее состояние- состояние, которое задается двумя допускающими состояниями.\\
4)функция перехода соответствует функции перехода магазинного автомата и автомата, то есть если мы находимся в состоянии ij и принамаем символ к, а магазинный автомат переходит из i по к в состояние q и кладет в стек символ G, а автомат переходит из j по к в состояние H, то наш автомат перейдет в состояние qH и положит в стек G. \\
 
Теперь поймем, что слово w будет допускаться полученным автоматом тогда и только тогда, когда слово будет приниматься обоими автоматами, потому что принимающее состояние эквивалентно принимающим состояниям каждого из автоматов. Если же мы попали не в принимающее состояние, то это означает, что слово не принадлежит хотя бы одному из автоматов и поэтому оно не принадлежит нашему автомату.\\








\end{document}